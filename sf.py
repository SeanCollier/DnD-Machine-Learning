# -*- coding: utf-8 -*-
"""SF

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dzqua3ePEeSnFgD2qfDBq-3dahndOgkU
"""

!pip install -q --upgrade tensorflow     #installing prereqs for TF

from __future__ import absolute_import, division, print_function

import os
import matplotlib.pyplot as plt

import tensorflow as tf
import tensorflow.contrib.eager as tfe

tf.enable_eager_execution()

print("TensorFlow version: {}".format(tf.VERSION))
print("Eager execution: {}".format(tf.executing_eagerly()))

# Die rolling functions
import random

def d100(): #function to roll a d100
   roll = random.randint(1,100);
   return roll
  
  
def d20(): #function to roll a d20
   roll = random.randint(1,20) 
   return roll

def d12(): #function to roll a d12
   roll = random.randint(1,12) 
   return roll

def d10(): #function to roll a d10
   roll = random.randint(1,10) 
   return roll

def d8(): #function to roll a d8
   roll = random.randint(1,8) 
   return roll

def d6(): #function to roll a d6
   roll = random.randint(1,6) 
   return roll

def d4(): #function to roll a d4
   roll = random.randint(1,4) 
   return roll

i=1 #establish the first character number

#developing Brer (to be used as a template for futures)
#current level is 4 with cb mast and sharpshooter, arch fight style
class Brer:
  
  character_num = i
  i=i+1
  
  #char stats 
  hp_max = 37
  hp_current = 37
  sup_die_total = 3
  sup_die_curnt = 3
  AC = 18
  prof = 3
  arch = 2
  move_base = 6
  move_current = 6
  
  #modifiers
  con=3
  str=3
  dex=3
  chr=2
  wis=-1
  int=2
  
  
#####Brer atks
  base_attacks = 3
  current_attacks = 3
  lcb_tohit = dex + prof + arch
  lcb_dmg_bonus = dex
  
  ss_lcb_tohit = dex + prof + arch -5
  ss_lcb_dmg_bonus = dex + 10

  def sup_die_dmg(): #function to roll a d8 for superior damage die
    dmg = random.randint(1,8) 
    return dmg
  
  def lcb_dmg(): #function to roll for lcb damage
    dmg = random.randint(1,6)+Brer.lcb_dmg_bonus
    return dmg
  
  def ss_lcb_dmg(): #function to roll for lcb damage
    dmg = random.randint(1,6)+Brer.ss_lcb_dmg_bonus
    return dmg
  
  
  def attack(foe,dist): #Brer's attack no sharpshooter
    Brer.current_attacks = Brer.current_attacks-1
    if dist < 10000:
      atk = d20()+Brer.lcb_tohit
      if atk >= foe.AC:
        dmg = Brer.lcb_dmg()
        foe.hp_current=foe.hp_current-dmg
        print('attack hit for:')
      else:
        dmg=0
        print('attack missed')
    else:
      dmg=0
      print('not in range')
    print(dmg)
    return
        
  def ss_attack(foe,dist): #Brer's attack with sharpshooter
    Brer.current_attacks = Brer.current_attacks-1
    if dist < 10000:
      atk = d20()+Brer.ss_lcb_tohit
      if atk >= foe.AC:
        dmg = Brer.ss_lcb_dmg()
        foe.hp_current=foe.hp_current-dmg
        print('attack hit for:')
      else:
        dmg=0
        print('attack missed')
    else:
      dmg=0
      print('not in range')
    print(dmg)
    return

class mons:
  character_num = i
  i=i+1
#enemy hobgob captain stats
  hp_max = 37
  hp_current = 39
  AC = 17
  move_base = 6
  move_current = 6
  
#####enemy hobgob captain attack
  base_attacks = 2
  current_attacks = 2
  tohit =  4
  dmg_bonus = 2
  dex = 2
  
  
  def gs_dmg(): #function to roll greatsword damage
    dmg = random.randint(1,6) + random.randint(1,6)
    return dmg
  
  def attack(foe,dist): #Monster attack
    mons.current_attacks = mons.current_attacks-1
    if dist < 2:
      atk = d20()+mons.tohit
      if atk >= foe.AC:
        dmg = mons.gs_dmg()
        foe.hp_current=foe.hp_current-dmg
        print('attack hit for:')
      else:
        dmg=0
        print('attack missed')
    else:
      dmg=0
      print('not in range')
    return dmg
  
  diag_counter = 0

#Creating the battle grid
class map():
  x_size = 100 #each 1 equals 5 ft; 0 is far left
  y_size = 100 #each 1 equals 5 ft; 0 is bottom

  space = [0]*x_size
  for i in range(x_size):
    space[i] = [0] * y_size

#Generating  starting positions, controlled, and pretty far
Brer.pos = [25,25]
mons.pos = [75,75]

#placing them on the battle grid
map.space[Brer.pos[0]][Brer.pos[1]] = Brer.character_num
map.space[mons.pos[0]][mons.pos[1]] = mons.character_num

#Deciding initiative
Brer.initiative = [d20() + Brer.dex]
mons.initiative = [d20() + mons.dex]

while Brer.initiative == mons.initiative:
  Brer.initiative = [d20() + Brer.dex]
  mons.initiative = [d20() + mons.dex]


initiative_order = sorted([Brer,mons], key=lambda x: x.initiative, reverse=True)

#Matrix addition function -- to be used to combine values for linear movement
def matrixADD(A,B):
  Z = []
  #TODO
  for i in range(0,len(A)):
    for column in range(0, len(A)):
        result = A[i][column] + B[i][column]
        Z[i][column] = (result)
  return Z

Brer.pos

#Movement action

# what to do next is to reconstruct the previous parts of the code make
#brer and monster into classes that contain info about their everything,
#rather than have seperate info in different variables
class move:
  #all movement is currently centered in cartesian plane map.pos[x,y,z]
  total = 6
  
  def up(character):
    print(character.pos)
    #create a temporary vector that will contain the values of the current space
    tempx = int(character.pos[0])
    tempy = int(character.pos[1])
    character.pos[1] = character.pos[1]+1
    tempx2 = int(character.pos[0])
    tempy2 = int(character.pos[1])
    map.space[tempx2][tempy2] = character.character_num
    map.space[tempx][tempy] = 0
    character.move = character.move_current -1
    return character.pos
  
    
    
  def right(character): #move right command
    tempx = int(character.pos[0])
    tempy = int(character.pos[1])
    character.pos[0] = character.pos[0]+1
    tempx2 = int(character.pos[0])
    tempy2 = int(character.pos[1])
    map.space[tempx2][tempy2] = character.character_num
    map.space[tempx][tempy] = 0
    character.move = character.move_current -1
    return character.pos
    
    
    
  def down(character): #move down command
    tempx = int(character.pos[0])
    tempy = int(character.pos[1])
    character.pos[0] = character.pos[1]-1
    tempx2 = int(character.pos[0])
    tempy2 = int(character.pos[1])
    map.space[tempx2][tempy2] = character.character_num
    map.space[tempx][tempy] = 0
    character.move = character.move_current -1
    return character.pos
  
    
   
  def left(character): #move left command
    tempx = int(character.pos[0])
    tempy = int(character.pos[1])
    character.pos[0] = character.pos[0] -1
    tempx2 = int(character.pos[0])
    tempy2 = int(character.pos[1])
    map.space[tempx2][tempy2] = character.character_num
    map.space[tempx][tempy] = 0
    character.move = character.move_current -1
    return character.pos
  
  def upright(character): #move diagonally up-right command
    tempx = int(character.pos[0])
    tempy = int(character.pos[1])
    character.pos[0] = character.pos[0]+1
    character.pos[1] = character.pos[1]+1
    tempx2 = int(character.pos[0])
    tempy2 = int(character.pos[1])
    map.space[tempx2][tempy2] = character.character_num
    map.space[tempx][tempy] = 0
    
    if character.diag_counter == 0:
      character.diag_counter = character.diag_counter +1
      character.move = character.move_current -1
    elif character.diag_counter == 1:
      character.diag_counter = character.diag_counter -1
      character.move = character.move_current -2
    return character.pos
  
  def upleft(character): #move diagonally up-left command
    tempx = int(character.pos[0])
    tempy = int(character.pos[1])
    character.pos[0] = character.pos[0]-1
    character.pos[1] = character.pos[1]+1
    tempx2 = int(character.pos[0])
    tempy2 = int(character.pos[1])
    map.space[tempx2][tempy2] = character.character_num
    map.space[tempx][tempy] = 0
    
    if character.diag_counter == 0:
      character.diag_counter = character.diag_counter +1
      character.move = character.move_current -1
    elif character.diag_counter == 1:
      character.diag_counter = character.diag_counter -1
      character.move = character.move_current -2
    return character.pos
  
  def downright(character): #move diagonally down-right command
    tempx = int(character.pos[0])
    tempy = int(character.pos[1])
    character.pos[0] = character.pos[0]+1
    character.pos[1] = character.pos[1]-1
    tempx2 = int(character.pos[0])
    tempy2 = int(character.pos[1])
    map.space[tempx2][tempy2] = character.character_num
    map.space[tempx][tempy] = 0
    
    if character.diag_counter == 0:
      character.diag_counter = character.diag_counter +1
      character.move = character.move_current -1
    elif character.diag_counter == 1:
      character.diag_counter = character.diag_counter -1
      character.move = character.move_current -2
    return character.pos
  
  def downleft(character): #move diagonally up-right command
    tempx = int(character.pos[0])
    tempy = int(character.pos[1])
    character.pos[0] = character.pos[0]-1
    character.pos[1] = character.pos[1]-1
    tempx2 = int(character.pos[0])
    tempy2 = int(character.pos[1])
    map.space[tempx2][tempy2] = character.character_num
    map.space[tempx][tempy] = 0
    
    if character.diag_counter == 0:
      character.diag_counter = character.diag_counter +1
      character.move = character.move_current -1
    elif character.diag_counter == 1:
      character.diag_counter = character.diag_counter -1
      character.move = character.move_current -2
    return character.pos

"""the next goal will be to construct a round of combat, possibly using a neural net architecture? Not sure, because the mechanics are there, we just need to construct a way for the machines to implement them.
  
fitness should be decided based on dealing damage (+), avoiding damage(-), and winning the round(+++)
"""

#Hobgoblin moving objective -> get closer to Brer
import numpy
#find the distance between two points, returns how many vertical, horiz and
  #absolute the character must move in regards to a second character
def distance_find(char2,char1):
  x_dist = char1.pos[0]-char2.pos[0]
  y_dist = char1.pos[1]-char2.pos[1]
  abs_dist = ((char1.pos[0]-char2.pos[0])**2+((char1.pos[1]-char2.pos[1])**2))**0.5
  return (x_dist,y_dist,abs_dist)

# Hob goblin moving objective, very basic distance closing algorithm

while mons.move_current > 0:
  current_dist = distance_find(mons,Brer)
  
  if abs(current_dist[0]) > abs(current_dist[1])*2: #general pursuit in horiz dir
    if current_dist[0] > 0:
      right(mons)
      mons.move_current = mons.move_current-1
    elif current_dist[0] < 0:
      left(mons)
      mons.move_current = mons.move_current-1
      
  elif abs(current_dist[1]) > abs(current_dist[0])*2: #general pursuit in vert dir
    if current_dist[0] > 0:
      up(mons)
      mons.move_current = mons.move_current-1
    elif current_dist[0] < 0:
      down(mons)
      mons.move_current = mons.move_current-1
      
  elif abs(current_dist[0]) > abs(current_dist[1]) and abs(current_dist[0]) < abs(current_dist[1])*2: #pursuit in diag rights
    if current_dist[0] > 0:
      if current_dist[1] > 0: 
        upright(mons)
        mons.move_current = mons.move_current-1
      elif current_dist[1] < 0: 
        downright(mons)
        mons.move_current = mons.move_current-1
        
    elif current_dist[0] < 0:
      if current_dist[1] > 0: 
        upleft(mons)
        mons.move_current = mons.move_current-1
      elif current_dist[1] < 0: 
        downleft(mons)
        mons.move_current = mons.move_current-1

Brer.pos
current_dist = distance_find(mons,Brer)
current_dist